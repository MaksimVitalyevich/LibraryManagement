@page
@model LibraryManagement.Pages.ProjectIssuesModel
@{
	ViewData["Title"] = "Список известных проблем и трудностей";
}

<h1>@ViewData["Title"]</h1>

<section class="proj-knownproblems">
	<h2>Трудности, возникшие во время разработки...</h2>
	<p>
		<strong>1. Общие модели/шаблоны и Razor:</strong><br />
		На данном стадии разработки, во время попытки создать абстрактные модели Razor страниц возникла серьезное ограничение:
		Фреймворк НЕ поддерживает работу с шаблонами страниц, особенно в попытке передать данные моделей шаблонов прямо в Razor. 
		Попытка использовать такие шаблоны вызывала исключения во время компиляции с Razor. Это повлияло на работу самих сервисов,
		в попытке универсально интсацинировать каие-либо данные.
	</p>
	<p>
		<strong>Решение проблемы:</strong><br />
		<code>BookMediator</code> был создан данный класс. Посредник, вручную собирающий списки
		нужных сервисов (<i>Исторические, Справочники, Современные</i>), разделенные по категориям. Основной сервис однако сохранен
		для цепочки вызовов, НО НЕ позволяет напрямую создавать общие неизвестные модели книг. Служат абстракцией по отношению к 
		DI зависимостям.
	</p>
	<br />
	<p>
		<strong>2. Удаление книг по ID:</strong><br />
		Изначально, Наблюдалась проблема при удалении книг, поскольку они ввсе находились в общей таблице.
		Каждая запись книги помечалась к конкретной категории. Формирование отдельной кнопки при заполнении данных книги оказалась 
		бесмысленной: это не обеспечивало удобство в работе и могло вызывать ошибки при передаче данных.
	</p>
	<p>
		<strong>Решение проблемы:</strong><br />
		Идея создать <strong>динамическую кнопку удаления</strong>. Оно генерируется рядом с каждой моделью любой книги.
		Процесс удаления проверяет категорию книги и ID выбранной из. В дополнении, обеспечивало параметр <code>{id?}</code>
		на странице формы. Это помогало более точно обработать подобную операцию!
	</p>
	<br />
	<p>
		<strong>3. Динамическое создание страниц и потеря специфичных данных полей:</strong><br />
		Каждая модель имеет свои специфичные поля данных, которые должны отображаться ТОЛЬКО когда был выбран подходящий тип
		(например: <code>GuideBook</code>). Хотя и данные генерировались на общей форме как положено, после выполнения 
		<code>OnPostSave()</code> данные с таких полей терялись, и в результате туда сохранялся <code>null</code>. 
		Это бы непременно вызвало критическую ошибку типа<code>NullReferenceException</code> в попытке обратиться к таким данным.
	</p>
	<p>
		<strong>Решение проблемы:</strong><br />
		<strong>Частичные представления</strong> - это великолепный концепт формирования динамичных данных! Страницы без кода, 
		которые просто формируют специфичные поля данных. Каждая книга нследуется от общей модели <code>BookBase</code>,
		включая унифицированные поля данных. Специфичные поля в таком случае,соединены с представлением <code>&It;partial&gt;</code> 
		с использованием <code>Html.PartialAsync()</code>. Таким образом, форма остается как общая, но динамически заполнятеся нужными 
		фрагментами, в зависимости от типа книги.
	</p>
	<br />
	<p>
		<strong>4. Передававшеяся ссылка сервиса книги - создавалась по-новой:</strong><br />
		Похоже что регистрация одних интерфейсов - недостаточно для корректной передачи данных модели! Новая книга - просто не записывалась
		в существующий список всех книг и не отображалась! Даже при наличии регистрации всех сервисов - не приводило к результату.
	</p>
	<p>
		<strong>Решение проблемы:</strong><br />
		<code>BookAdapterService</code> И <code>IBookService</code> разрешили корректную передачу ссылок! Теперь, гарантировано
		передается ИМЕННО изначальная ссылка на сервис. Как бонус, сама регистрация - по интерфейсам, чтобы явно не передавать типизированные
		конструкции. В общий список при создании новой модели, корректно появится новая книга в зависимости от типа.
	</p>
	<br />
	<p>
		<strong>5. Изменение системы маршрутизации и передачи параметров + дублирование ID:</strong><br />
		Изначально книга идентифицировалась по <code>ID</code>, что вызывало неоднозначность - книги разных категорий могли иметь
		повторяющиеся индексатор. Также с таким подходом не происходила гибкая фильтрация и вызывала путаницу передачи параметров по URL.
		А из-за одинаковости записи ID - получалось вроде: <code>0, 1</code>, причем в обеих категориях!
	</p>
	<p>
		<strong>Решение проблемы:</strong><br />
		Система идентификации полностью переработана: вместо ID используется комбинация <code>Title + Publication</code>
		(<code>int year, string title</code>), которая гарантирует уникальность каждой книги в URL и маршрутах.
		Благодаря этому, стал корректным подход маршрутизировать URL, проводить удобную навигацию и избежать возможных конфликтов 
		при добавлении новых книг.
	</p>
	<br />
	<p>
		<strong>6. Неоднозначность вызова метода редактирования при сипользовании общей формы:</strong><br />
		Одна и та же форма <code>FormEdit.cshtml</code> использовалась как для создания, так и для редактирования книг.
		Однако методы в контроллере были четко разделены: один <code>[HttpPost]FormEdit</code> обрабатывал <strong>Создание</strong>
		книги, другой <strong>Редактирование</strong> уже существующей. Визуально форма открывалась корректно,
		но при нажатии кнопки "Сохранить" происходила простая перезагрузка текущей страницы - изменении никаких,
		впоследствии пользователь не переходил к списку книг.
	</p>
	<p>
		<strong>Решение проблемы:</strong><br />
		Была разделеня логика вызова и обработки сохранения книги. Использован вызов
		<code>Url.Action(Имя_Метода, Имя_Контроллера, Параметры URL)</code> - он гибко и явно указывает, какой метод
		<code>FormEdit</code> должен быть вызван. Это особенно важно, поскольку сама кнопка "Редактировать" находилась
		внутри ячейки таблицы рядом с информацией книги. После сохранения теперь корректно выполняется переход
		обратно к списку книг с учетом внесенных изменении.
	</p>
	<a asp-page="/About">Вернутся к странице "О проекте..."</a>
</section>
